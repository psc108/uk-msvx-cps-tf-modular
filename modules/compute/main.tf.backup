##### Compute Module - EC2 Instances #####

##### Jump Server #####
resource "aws_instance" "jump-server" {
  ami                         = var.ami_id
  instance_type               = "t2.large"
  subnet_id                   = var.public_subnets[0].id
  associate_public_ip_address = true
  iam_instance_profile        = var.ssm_instance_profile.name
  monitoring                  = true

  vpc_security_group_ids = [
    var.security_groups.jump_server.id,
    var.security_groups.external_web_access.id,
    var.security_groups.efs.id
  ]

  root_block_device {
    delete_on_termination = true
    encrypted             = true
    iops                  = 3000
    volume_size           = 50
    volume_type           = "gp3"
  }

  tags = {
    Name        = "${var.environment}-jump-server"
    Environment = var.environment
    PatchGroup  = "${var.environment}-cso-instances"
    Backup      = "required"
    Monitoring  = "enabled"
  }

  user_data = base64encode(<<-EOF
    #!/bin/bash
    exec > /var/log/jump-server-setup.log 2>&1
    
    echo "Starting jump server setup at $(date)"
    
    # Install packages
    dnf update -y
    dnf install -y awscli amazon-ssm-agent nfs-utils java-21-amazon-corretto unzip openssl
    systemctl enable amazon-ssm-agent
    systemctl start amazon-ssm-agent
    
    # Create ecs user
    useradd -m -s /bin/bash ecs
    
    # Mount EFS with proper error handling and subnet fallback
    mkdir -p /opt/scripts
    echo "Mounting EFS: ${var.efs_dns_name}"
    
    # Wait for EFS to be available
    timeout 5m sh -c 'while ! nslookup ${var.efs_dns_name}; do echo "Waiting for EFS DNS..."; sleep 10; done'
    
    # Mount with retry logic - try from current subnet first, then any available mount target
    EFS_MOUNTED=false
    for i in {1..5}; do
      if mount -t nfs4 -o nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2 ${var.efs_dns_name}:/ /opt/scripts; then
        echo "EFS mounted successfully from current subnet"
        EFS_MOUNTED=true
        break
      else
        echo "EFS mount attempt $i failed, retrying..."
        sleep 10
      fi
    done
    
    # If mount failed, try alternative mount targets (for subnet flexibility)
    if [ "$EFS_MOUNTED" = "false" ]; then
      echo "Trying alternative EFS mount approaches..."
      # Try with different NFS options
      for i in {1..3}; do
        if mount -t nfs4 -o nfsvers=4.1,rsize=65536,wsize=65536,hard,timeo=600,retrans=2 ${var.efs_dns_name}:/ /opt/scripts; then
          echo "EFS mounted successfully with alternative options"
          EFS_MOUNTED=true
          break
        fi
        sleep 5
      done
    fi
    
    # Add to fstab
    echo '${var.efs_dns_name}:/ /opt/scripts nfs4 nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2 0 0' >> /etc/fstab
    
    # Verify mount
    if ! mountpoint -q /opt/scripts; then
      echo "ERROR: EFS mount failed after all attempts"
      echo "Available mount targets and network connectivity:"
      nslookup ${var.efs_dns_name} || echo "DNS resolution failed"
      ping -c 3 ${var.efs_dns_name} || echo "Ping failed"
      exit 1
    fi
    
    echo "EFS mount verification successful"
    df -h /opt/scripts
    
    # Wait for S3 files to be uploaded (especially the large installation package)
    echo "Waiting for S3 files to be available..."
    timeout 30m sh -c 'while ! aws s3 ls s3://${var.user_data_base.s3_bucket}/installation-package-2.4-SPRINT4i.jar; do echo "Waiting for installation package upload..."; sleep 30; done'
    
    # Download large files to local storage first, then copy to EFS
    echo "Downloading large installation package to local storage first..."
    aws s3 cp s3://${var.user_data_base.s3_bucket}/installation-package-2.4-SPRINT4i.jar /tmp/ \
      --cli-read-timeout 0 --cli-connect-timeout 60 --retry-mode adaptive --max-attempts 10
    
    # Download other files directly to EFS
    cd /opt/scripts
    echo "Downloading other files from S3 bucket: ${var.user_data_base.s3_bucket}"
    aws s3 sync s3://${var.user_data_base.s3_bucket}/ ./ --exclude "installation-package-*.jar"
    
    # Copy large file from local storage to EFS with transfer stats
    if [ -f /tmp/installation-package-2.4-SPRINT4i.jar ]; then
      echo "Copying installation package from local storage to EFS..."
      echo "Source file size: $(ls -lh /tmp/installation-package-2.4-SPRINT4i.jar | awk '{print $5}')"
      echo "Copy started at: $(date)"
      
      # Use pv for progress if available, otherwise use time with cp
      if command -v pv >/dev/null 2>&1; then
        pv /tmp/installation-package-2.4-SPRINT4i.jar > /opt/scripts/installation-package-2.4-SPRINT4i.jar
      else
        time cp /tmp/installation-package-2.4-SPRINT4i.jar /opt/scripts/
      fi
      
      echo "Copy completed at: $(date)"
      echo "Destination file size: $(ls -lh /opt/scripts/installation-package-2.4-SPRINT4i.jar | awk '{print $5}')"
      
      # Verify file integrity
      SRC_SIZE=$(stat -c%s /tmp/installation-package-2.4-SPRINT4i.jar)
      DST_SIZE=$(stat -c%s /opt/scripts/installation-package-2.4-SPRINT4i.jar)
      
      if [ "$SRC_SIZE" -eq "$DST_SIZE" ]; then
        echo "File integrity verified: $SRC_SIZE bytes"
        rm /tmp/installation-package-2.4-SPRINT4i.jar
        echo "Installation package copied successfully"
      else
        echo "ERROR: File size mismatch - Source: $SRC_SIZE, Destination: $DST_SIZE"
        exit 1
      fi
    else
      echo "ERROR: Installation package not downloaded"
      exit 1
    fi
    
    # Set permissions on all downloaded files
    chmod -R 755 .
    chown -R root:root .
    
    echo "Files downloaded from S3:"
    ls -la
    
    # Create required directories
    mkdir -p ssl/ca database ssp install
    
    # Generate SSL certificates
    echo "Generating SSL certificates..."
    cd ssl
    openssl genrsa -out ca/ca.key 4096
    openssl req -new -x509 -days 3650 -key ca/ca.key -out ca/ca.crt -subj "/C=US/ST=State/L=City/O=Organization/CN=CSO-CA"
    
    # Create service certificates
    for host in frontend01 frontend02 backend01 backend02 keystone01 keystone02 rabbitmq01 rabbitmq02; do
      mkdir -p $host && cd $host
      openssl genrsa -out server.key 2048
      openssl req -new -key server.key -out server.csr -subj "/C=US/ST=State/L=City/O=Organization/CN=$host.${var.environment}.cso.internal"
      openssl x509 -req -in server.csr -CA ../ca/ca.crt -CAkey ../ca/ca.key -CAcreateserial -out server.crt -days 365
      cd ..
    done
    
    cd /opt/scripts
    
    # Create database setup scripts
    cat > database/create_keystone_db.sql << 'DBEOF'
CREATE DATABASE IF NOT EXISTS keystone;
GRANT ALL PRIVILEGES ON keystone.* TO 'keystone'@'%' IDENTIFIED BY 'keystonepass';
FLUSH PRIVILEGES;
DBEOF
    
    # Create setup.properties from quickSetup.properties if available
    if [ -f quickSetup.properties ]; then
      cp quickSetup.properties ssp/setup.properties
    else
      echo 'mysql-hostname=localhost' > ssp/setup.properties
      echo 'keystone-password=keystonepass' >> ssp/setup.properties
      echo 'service-password=servicepass' >> ssp/setup.properties
    fi
    
    # Copy setup.properties to install directory
    cp ssp/setup.properties install/
    
    # Copy ALL jar files to install directory
    echo "Copying jar files to install directory..."
    find . -name "*.jar" -type f -exec cp {} install/ \;
    
    # List what we copied
    echo "Files in install directory:"
    ls -la install/
    
    # Create symlink
    rm -rf /opt/install 2>/dev/null || true
    ln -sf /opt/scripts/install /opt/install
    
    # Verify symlink works
    echo "Symlink verification:"
    ls -la /opt/install/
    
    # Create completion flag
    touch /opt/scripts/.setup-complete
    
    echo "Jump server setup completed successfully at $(date)"
    echo "Setup completion flag created"
    ls -la /opt/scripts/.setup-complete
  EOF
  )

  depends_on = [var.efs_mount_targets]
}